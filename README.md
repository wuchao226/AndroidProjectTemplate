# AndroidProjectTemplate
Android 项目模版-工程框架基础层
## 模块
* * *
- app:  
    app壳 工程，是依赖所有组件的壳，该模块不应该包含任何代码，它只作为一个空壳存在，由于项目中使用了EventBusAPT技术，需要索引到各业务组件的对应的APT生成类，所以在 app壳 内有这一部分的代码。

- buildSrc:  
这是一个特殊的文件夹，负责项目的构建，里面存放着一些项目构建时用到的东西，比如项目配置，依赖。这里面还是存放 Gradle 插件的地方，一些自定义的 Gradle 的插件都需要放在此处。

- lib_base:   
项目的基础公共模块，存放着各种基类封装、对远程库的依赖、以及工具类、三方库封装，该组件是和项目业务无关的，和项目业务相关的公共部分需要放在 lib_common 中。

- lib_common:  
项目的业务公共模块，这里面存放着项目里各个业务组件的公共部分，还有一些项目特定需要的一些文件等，该组件是和项目业务有关系的。

## 组件化相关
* * *
### 组件初始化
>  为了更好的代码隔离与解耦，在特定组件内使用的SDK及三方库，应该只在该组件内依赖，不应该让该组件的特定SDK及三方库的API暴露给其他不需要用的组件。有一个问题就出现了，SDK及三方库常常需要手动去初始化，而且一般都需要在项目一启动（即 Application 中）初始化，但是一个项目肯定只能有一个自定义的 Application，该项目中的自定义 Application 在 lib_base 模块中，并且也是在 lib_base 模块中的清单文件中声明的，那其他组件该如何初始化呢？带着这个问题我们一起来深入研究下。
#### 常见的组件初始化解决方案：
在我的了解范围内，目前有两种最为常见的解决方案：

- **面向接口编程 + 反射扫描实现类**：  
  该方案是基于接口编程，自定义 Application 去实现一个自定义的接口（interface），这个接口中定一些和 Application 生命周期相对应的抽象方法及其他自定义的抽象方法，每个组件去编写一个实现类，该实现类就类似于一个假的自定义 Application，然后在真正的自定义 Application 中去通过反射去动态查找当前运行时环境中所有该接口的实现类，并且去进行实例化，然后将这些实现类收集到一个集合中，在 Application 的对应声明周期方法中去逐一调用对应方法，以实现各实现类能够和 Application 生命周期相同步，并且持有 Application 的引用及 context 上下文对象，这样我们就可以在组件内模拟 Application 的生命周期并初始化SDK和三方库。使用反射还需要做一些异常的处理。该方案是我见过的最常见的方案，在一些商业项目中也见到过。

- **面向接口编程 + meta-data + 反射**：  
  该方案的后半部分也是和第一种方法一样，通过接口编程实现 Application 的生命周期同步，其实这一步是避免不了的，在我的方案中，后半部分也是这样实现的。不同的是前半部分，也就是如何找到接口的实现类，该方案使用的是 AndroidManifest 的 meta-data 标签，通过每个组件内的 AndroidManifest 内去声明一个 meta-data 标签，包含该组件实现类的信息，然后在 Application 中去找到这些配置信息，然后通过反射去创建这些实现类的实例，再将它们收集到一个集合中，剩下的操作基本相同了。该方案和第一种方案一样都需要处理很多的异常。这种方案我在一些开源项目中见到过，个人认为过于繁琐，还要处理很多的异常。

#### 本项目中所使用的方案：
- **面向接口编程 + Java的SPI机制（ServiceLoader）+AutoService**：  
    先来认识下 Java 的 SPI 机制：面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候不用在程序里动态指明，这就需要一种服务发现机制。JavaSPI 就是提供这样的一个机制：为某个接口寻找服务实现的机制。这有点类似 IOC 的思想，将装配的控制权移到了程序之外。这段话也是我复制的别人的，听起来很懵逼，大致意思就是我们可以通过 SPI 机制将实现类暴露出去。关于如何使用 SPI，这里不在陈述，总之是我们在各组件内通过 SPI 去将实现类暴露出去，在 Application 中我们通过 Java 提供的 SPI API 去获取这些暴露的服务，这样我们就拿到了这些类的实例，剩下的步骤就和上面的方案一样了，通过一个集合遍历实现类调用其相应的方法完成初始化的工作。由于使用 SPI 需要在每个模块创建对应的文件配置，这比较麻烦，所以我们使用 Google 的 AutoService 库来帮助我们自动创建这些配置文件，使用方式也非常的简单，就是在实现类添加一个 AutoService 注解。本框架中的核心类是这几个：lib_base-LoadModuleProxy、lib_base-ApplicationLifecycle。这种方案是我请教的一个米哈游的大佬，这位大佬告诉我在组件化中组件的初始化可以使用 ServiceLoader 来做，于是我就去研究了下，最后发现这种方案还不错，比前面提到的两种方案都要简单、安全。
### 资源命名冲突
  在组件化方案中，资源命名冲突是一个比较严重的问题，由于在打包时会进行资源的合并，如果两个模块中有两个相同名字的文件，那么最后只会保留一份，如果不知道这个问题的小伙伴，在遇到这个问题时肯定是一脸懵逼的状态。问题既然已经出现，那我们就要去解决，解决办法就是每个组件都用固定的命名前缀，这样就不会出现两个相同的文件的现象了，我们可以在 build.gradle 配置文件中去配置前缀限定，如果不按该前缀进行命名，AS 就会进行警告提示，配置如下：

```kotlin
android {
    resourcePrefix "前缀_"
}
```
## 版本管理相关
如果你的项目是小项目，或者组件比较少，或者不是组件化项目，我推荐你使用 Catalogs + Kotlin DSL 的方式，相对更完美，只需要在每一个模块都写一份配置文件而已。

如果你的项目是大型项目，并且有很多的子组件，那么我推荐你使用 Catalogs + Groovy DSL 的方式，封装一份 gradle 基类方便统一集中的管理。

- configBasic.gradle:   
  封装一个基类的公共配置,（一般不直接使用），只是给别的配置文件继承使用
- configModule.gradle：  
  子模块的gradle基类
- configRunning.gradle：  
  app宿主或独立运行模块需要的依赖, 主要是配置一些签名，编译信息
- configLib.gradle：  
  底层依赖库的gradle配置, 一般用于第三方的依赖库Lib基本的继承这个配置
### BuildSrc + Kotlin DSL 
[Android项目开发模板开源与相关介绍](https://juejin.cn/post/7341840038964477971)

BuildSrc + Kotlin DSL 的方案的主要特点是编译会稍慢，可能需要处理依赖版本冲突问题，好处是熟悉的Kotlin语法，与良好的代码导航支持
### Catalogs + Groovy DSL
Catalogs + Groovy DSL 的方案特点是虽然支持了代码导航，但是支持程度没有 Kotlin DSL 好，好处是编译速度更快，都在一个 Project 中版本冲突问题会缓解。
### Catalogs + Kotlin DSL
Catalogs + Kotlin DSL 的方案特点中和个上面两种方案的优点，无需新项目编译，完美的代码导航，友好的语言环境，但是无法像上面两种方案进行封装使用。
